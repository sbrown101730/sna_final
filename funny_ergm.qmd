---
title: "funny_ergm"
author: "Katie Lam"
date: today 
format: html
editor_options: 
  chunk_output_type: console
---

```{r}
#| echo: false
#| output: false
#| message: false

rm(list=ls())

# Lab 3:
# Exponential Random Graph Models (ERGMs)

# Clear your environment
rm(list=ls())

# Install packages below if you do not have them:
# -------------------------------------------------
if (!"statnet" %in% installed.packages()) install.packages("statnet") # For fitting ERGMs
if (!"igraph" %in% installed.packages()) install.packages("igraph") # For network plotting
if (!"texreg" %in% installed.packages()) install.packages("texreg") # For printing "nicer" model output

library(statnet)
library(readr)

# -------------------------------------------------------------------------------------------------
# Set the working directory
# Session > Set Working Directory > To Source File Location
# -------------------------------------------------------------------------------------------------
list.files() # List the files in the current working directory to see if you're in the right directory

```

```{r}
#| echo: false
#| output: false
#| message: false
#| label: load data

library(dplyr) 
library(tidyverse)

hyperlink_large <- read_tsv("data/soc-redditHyperlinks-body.tsv") %>%
  janitor::clean_names() %>%
  select(source_subreddit, target_subreddit)

# read csv
popularity_large <- read_csv("data/subreddits_public.csv")

popularity_clean <- popularity_large %>%
  mutate(subreddit_name = str_to_lower(subreddit_name))

funny_1 <- hyperlink_large %>%
  janitor::clean_names() %>%
  filter(source_subreddit == "funny" | target_subreddit == "funny")
  
funny_2 <- hyperlink_large %>%
  janitor::clean_names() %>%
  filter(source_subreddit %in% funny_1$source_subreddit | 
           target_subreddit %in% funny_1$target_subreddit |
           source_subreddit %in% funny_1$target_subreddit |
           target_subreddit %in% funny_1$source_subreddit)
  
funny_3 <- funny_2 %>%
  count(source_subreddit, target_subreddit) %>%
  filter(n > 35)

popularity <- popularity_clean %>%
  filter(subreddit_name %in% funny_3$source_subreddit | 
           subreddit_name %in% funny_3$target_subreddit) %>%
  select(subreddit_name, subscribers_count) %>%
  mutate(
    subscribers_count = as.numeric(subscribers_count),
    size = case_when(
      subscribers_count <= 10000 ~ "small",
      subscribers_count <= 50000 ~ "medium",
      subscribers_count > 50000 ~ "large"
    ),
    size = size %>% 
      replace_na("missing")
  ) %>% 
  arrange(subreddit_name)

summary(popularity)
# 
# subreddits <- unique(c(hyperlink$source_subreddit, hyperlink$target_subreddit))
# 
# popularity[!(popularity$subreddit_name %in% subreddits)]

```


# 1. funny
```{r}
#| echo: false
#| output: false
#| message: false

# View the first rows of the edgelist to make sure it imported correctly:
head(funny_3)
# Convert the edgelist to a network object in statnet format:
funny_net <- as.network.matrix(funny_3, matrix.type = "edgelist") 

plot(funny_net)
# # 
# # funny_net |> 
# #   network::set.edge.attribute("sentiment", value = funny$sentiment)
# 
# funny_net |>
#   network::set.vertex.attribute("num_subs", value = popularity$subscribers_count)
# 
funny_net |>
  network::set.vertex.attribute("size", value = popularity$size)

funny_net
# 
# # View a summary of the network object
# funny_net
# 
# # Check vertex attribute
network::get.vertex.attribute(funny_net,"vertex.names")
# 
# # Check edge attribute
network::get.vertex.attribute(funny_net,"size")

```


```{r}
# ----------------------------------------------------------------------------
# Visualize networks
# ----------------------------------------------------------------------------
library('igraph') # Ignore messages on any objects that are masked

# Set default plot options
igraph_options(vertex.size = 2, vertex.color = 'grey', # vertex.size changes the size of nodes; vertex.color changes the color of nodes
               edge.color='gray80', edge.arrow.size=.1, # edge.color changes the color of ties; edge.arrow.size changes the size of tie arrow heads
               vertex.label = NA)                       # vertex.label = NA specifies not to display vertex labels in the plot

# Plot the Advice network
funny_igraph <- graph.adjacency(as.matrix.network(funny_net)) # make an igraph network object from statnet network object

funny_igraph <- set_vertex_attr(funny_igraph, "popularity", value = network::get.vertex.attribute(funny_net,"size"))

count_components(funny_igraph)
# Calculates and stores a spring-embedded layout
                                           # We will re-use this same layout for each plot, so nodes are always in the same place


```


```{r}
#| echo: false
#| output: false
#| message: false

# # View the first rows of the edgelist to make sure it imported correctly:
# head(hyperlink)
# # Convert the edgelist to a network object in statnet format:
# funny_net <- as.network.matrix(hyperlink, matrix.type = "edgelist") 
# 
# funny_net |>
#   network::set.vertex.attribute("num_subs", value = popularity$subscribers_count)
# 
# funny_net |>
#   network::set.vertex.attribute("size", value = popularity$size)
# 
# # View a summary of the network object
# funny_net
# 
# # Check vertex attribute
# network::get.vertex.attribute(funny_net,"size")

```

## 1. Plot the base (Advice) network and include it in your report. **(5 pts)**

- Noticeable centrality for one node

```{r}
#| label: giant component

reddit_comp <- igraph::components(funny_igraph)
giantGraph_funny <- funny_igraph %>%
  induced_subgraph(., which(reddit_comp$membership == which.max(reddit_comp$csize)))

plot(giantGraph_funny)

library(intergraph)

funny_giant <- asNetwork(giantGraph_funny)

funny_giant
# vcount(gpt_graph) ## the number of nodes/actors/users
# ecount(gpt_graph) ## the number of edges
```
# DONE Part II: Model Estimation (55 pts)

## 1. Build two ERGM models to test the hypotheses using the different network statistics described below **(15 pts)**

```{r}
# ----------------------------------------------------------------------------
######################## PART II: Build the ERGM models ########################
#
# R vignette for more details: https://cran.r-project.org/web/packages/ergm/ergm.pdf
# ----------------------------------------------------------------------------
# detach(package:igraph) # Remove the 'igraph' package from your environment. 
library(statnet)
options(ergm.loglik.warn_dyads=FALSE) #Whether or not a warning should be issued when sample space constraints render the observed number of dyads ill-defined

# Ergm Terms are statistics: They are some deterministic function of the ties, node attributes, and edge covariates of a network.
help("ergm-terms",package = "ergm") # Documentation that contains definitions for all of the terms we are using
                                    # ex. what does "mutual" test and how is it calculated
# We will use the ergm-terms to perform hypothesis testing using ERGMs
# But we can note that any of the ERGM terms can also be examined directly for your observed network, by creating a formula in R

# Look at Endogenous statistics: terms based on only ties in the advice network
summary(funny_giant ~ edges)                     # Number of edges (ties)
summary(funny_giant ~ mutual)                    # Number of pairs of reciprocated ties
summary(funny_giant ~ odegree(0:5))              # Outdegree distribution. (# of nodes with outdegree of 0, # nodes outdegree of 1, etc.)
                                           # Remember, respondents could nominate at most five employees in our survey
summary(funny_giant ~ idegree(0:65))             # Indegree distribution.
summary(funny_giant ~ gwodegree(log(2),fixed=T)) # One parameter summarizing outdegree distribution - tendency against outdegree hubs
summary(funny_giant ~ gwidegree(log(2),fixed=T)) # One parameters summarizing indegree distribution - tendency against indegree hubs
summary(funny_giant ~ desp(1:5))  

funny_giant
# Pairs of nodes with one shared partner, two shared partners, etc.
# summary(funny_giant ~ dgwesp(log(2),fixed = T))  # One parameter summarizing 

# # Look at Exogenous statistics: terms based on advice ties AND other ties / node attributes
# summary(funny_net ~ edgeicov("sentiment"))             # Ties directed towards employees at the main office (as opposed to secondary office)
# summary(advice ~ nodeocov("office"))             # Ties originating from employees at the main office (as opposed to secondary office)

# remove missing
summary(funny_giant ~ nodematch("popularity", levels = -3, diff = TRUE)) 

# Number of ties between people of the same sex
 # summary(funny_net ~ nodematch("size"))        # Number of ties between people working in the same department
# summary(advice ~ nodemix("leader",levels2=NULL)) # Number of ties between different combinations of leaders(1) and non-leaders(0)
# summary(advice ~ diff("tenure"))                 # Total difference in tenure: sum of (sender's tenure - receivers-tenure) for all ties
#summary(advice ~ edgecov(sentiment))     # Total messages sent: sum of (messages sent from sender to receiver)/100 for all Advice ties
                                                # e.g., a total of 5669 messages were sent from employees to those they go to for advice during the observed period

# The above are statistics - counts of these patterns for our networks
# What fitting the ERGM model will tell is whether these counts are relatively high/low
# in comparison to what we would expect based on random chance, controlling for the other effects in our model.
# This type of analysis can be helpful for understanding your network, as well as troubleshooting issues with ERGM regression
```

Fit model 1 (simple model) and model 2 (complex model) using the terms already specified in the R script provided to you.

### Simple model

```{r}
#| message: false
# The following commands do model estimation for ERGMs.
# This may take a second. Text will print in-console to update you on progress in model estimation.
model1 <- ergm(funny_giant ~ edges          # This is  a tendency towards a greater number of advice ties existing. Based on a statistic counting the number of ties.
               # Structural patterns
               + mutual 
               
              + gwidegree(log(2),fixed=T)
               
               + nodematch("popularity", levels = -3)
               # 
               # + gwodegree(log(2),fixed=T) # This is a tendency towards reciprocity for the advice ties. Based on a statistic counting the number of reciprocated ties.
               #+ edgecov(hundreds_messages)  # This is the effect of every 100 messages sent from i->j on likelihood of an advice tie. Based on a weighted sum of advice ties x 100s of messages sent
               #+ nodemix("leader",base = 3)
               # Model constraints
               #, constraints =~ bd(maxout=5) # This constraint enforces the maximum outdegree is 5
               , control = control.ergm(seed = 42)
               , verbose = F
)
summary(model1)

## Convert a log-odds (e.g., -0.68122) ratio to an odds ratio
```

```{r}
# Easy side-by-side model comparison:
library(texreg)
screenreg(list("model1"=model1))
```
.

```{r}
par(mar=c(1,1,1,1))
mcmc.diagnostics(model1)
```

### MCMC Model 2

```{r}
par(mar=c(1,1,1,1))
mcmc.diagnostics(model2)
```

## 2. Perform Goodness of Fit test to check how well the estimated model captures certain statistical features of the observed network for both model 1 and 2. **(10 pts)**

a.  To do so, simulate many networks from the estimated model and extract 100 samples from the simulation process. Please note, this may take 2 minutes or more to compute.

```{r}
#| warning: false
# -------------------------------------------------------------------------------------------------
# Goodness of fit test - will display in RStudio
# Check how well the estimated model captures certain features of the observed network, for example triangles in the network.
# -------------------------------------------------------------------------------------------------
# Look at networks simulated according to model 1
# This first command simulates 100 networks.
# These networks, if we use sufficient burnin steps in the markov chain used to generate them,
# may be thought of as random samples from the joint probability distribution that is our fitted ERGM.
sim1 <- simulate(model1, burnin=100000, interval=100000, nsim=100, verbose=T)  # Uses the ergm model to simulate a null model
# Plot the first of the simulated networks
sim1_net1 <- igraph::graph.adjacency(as.matrix.network(sim1[[1]]))
igraph::plot.igraph(sim1_net1,layout=net_layout,edge.color="brown",  
                    vertex.color = 'grey',edge.arrow.size=.1)

# Plot the 10th simulated network
sim1_net10 <- igraph::graph.adjacency(as.matrix.network(sim1[[10]]))
igraph::plot.igraph(sim1_net10,layout=net_layout,edge.color="red",  
                    vertex.color = 'grey',edge.arrow.size=.1)


# # Repeat, now looking at networks simulated according to model 2
# sim2 <- simulate(model2, burnin=100000, interval=100000, nsim=100, verbose=T)  # Uses the ergm model to simulate a null model
# # Plot the first of the simulated networks
# sim2_net1 <- igraph::graph.adjacency(as.matrix.network(sim2[[1]]))
# igraph::plot.igraph(sim2_net1,layout=net_layout,edge.color="grey",  
#                     vertex.color = 'grey',edge.arrow.size=.1)                                                               
# # Plot the 10th simulated network
# sim2_net10 <- igraph::graph.adjacency(as.matrix.network(sim2[[10]]))
# igraph::plot.igraph(sim2_net10,layout=net_layout,edge.color="purple",  
#                     vertex.color = 'grey',edge.arrow.size=.1)
```

b.  Extract the number of triangles from each of the 100 samples.

```{r}
# -------------------------------------------------------------------------------------------------
# Extract the number of triangles from each of the 100 samples and
# compare the distribution of triangles in the sampled networks with the observed network
# -------------------------------------------------------------------------------------------------
# Model 1:
model1.tridist <- sapply(1:100, function(x) summary(sim1[[x]] ~triangle)) # Extracts the triangle data from the simulated networks
hist(model1.tridist,xlim=c(0,1000),breaks=10)                             # Plots that triangle distribution as a histogram, change xlim to change the x-axis range if necessary
advice.tri <- summary(funny_net ~ triangle)                                    # Stores the number of observed triangles
advice.tri
arrows(advice.tri,20, advice.tri, 0.5, col="red", lwd=3)                      # Adds an arrow to the plotted histogram
c(obs=advice.tri,mean=mean(model1.tridist),sd=sd(model1.tridist),
  tstat=abs(mean(model1.tridist)-advice.tri)/sd(model1.tridist))

# # Model 2:
# model2.tridist <- sapply(1:100, function(x) summary(sim2[[x]] ~triangle)) # Extracts the triangle data from the simulated networks
# hist(model2.tridist,xlim=c(0,1000),breaks=10)                             # Plots that triangle distribution as a histogram, change xlim to change the x-axis range if necessary
# arrows(advice.tri,20, advice.tri, 0.5, col="red", lwd=3)                    # Adds an arrow to the plotted histogram
# c(obs=advice.tri,mean=mean(model2.tridist),sd=sd(model2.tridist),
#   tstat=abs(mean(model2.tridist)-advice.tri)/sd(model2.tridist))
```

c.  Compare the distribution of triangles in the sampled networks with the observed network by generating a histogram of the triangles. Interpret your result -- is the estimated model a good one in terms of triangle measure?

The histogram of triangles shows that model 1 does not have that good of a fit for triangle measure because our observed model does not land in the distribution of random sampled networks. The t-stat is 6.784396 which is a bad fit. The boxplot created from the code below for `edgewise shared partners` also shows that the observed network does not align well with the other generated networks. This GOF calculation shows us that the goodness of fit for `edgewise shared partners` have an average low p-value (some values are 0), which we can use to conclude that model 1 is not good to measure triangles in the network. However, for the histogram of model 2, our observed network fits inside of the distribution which indicates that it is a good model in terms of triangle measure. Here, the t-stat is 0.2754067, which is between 0.1 and 1, signifying a good fit. Additionally the p-values for `edgewise shared partners` are also high and the distribution boxplot for `edgewise shared partners` matches mostly well with the observed data, indicating that the goodness of fit is good for model 2. 

```{r}
#| warning: false
# -------------------------------------------------------------------------------------------------
# Test the goodness of fit of the model
# Compiles statistics for these simulations as well as the observed network, and calculates p-values 
# -------------------------------------------------------------------------------------------------

# Model 1:
# It may take a second for this command to run.
gof1 <- gof(model1, verbose=T, burnin=1e+5, interval=1e+5, control = control.gof.ergm(nsim = 200))
# If you run below and then wouldn't see the plot, try par(mar=c(2,2,2,2))
dev.off()           # Clear any other plots from the plot window
plot(gof1)          # Plot the goodness of fit
                    # Note: This should produce five separate plots that you should look through.
                    #       In RStudio, scroll between the plots using the arrow buttons
gof1                # Display the goodness of fit info in the console
```

## 3. Repeat this goodness-of-fit evaluation process for a variety of other network statistics just for model 2 **(10 pts)**

*for example, degree distribution, distribution of edgewise shared partners, and the distribution of geodesics* Simulate networks as we did above, compile statistics for these simulations as well as the observed network, and calculate p-values of all of the aforementioned values to evaluate the correspondence between the networks simulated by the model and the observed network. Report the p-values for the simulation and interpret them.

## Degree Distribution: 
For indegree and outdegree distribution, the pvalues are relatively high suggesting an okay fit from degree distribution. Likewise the boxplot shows that the observed data falls relatively in the box of generated networks, more so for the indegree than outdegree. The range of p-values for indegree is 0 to 1, but there is only one 0 and the median value is 1. The range of p-values for outdegree is 0.04 to 0.7. Additionally, the inverted preferential attachments for indegree or outdegree also depict high p-values (0.99), implying that model 2 is an okay fit for degree distribution.

## Edgewise shared partners: 
The boxplot for `edgewise shared partners` show a relatively nice fit, but not the best. Most of the p-values are high, with the exception of the last row of the table, which has a p-value of 0.04. The range is 0.04 to 1. 

## Geodesics: 
The boxplot for `minimum geodesic distance` exemplifies a very tight fit and our observed network displays a good resemblance of the boxplot distributions. The high p-values also indicate that model 2's goodness of fit for geodesic distance is very good, with a range of 0.1 to 1. 

```{r}
#| warning: false
# Model 2:
# It may take a second for this command to run.
gof2 <- gof(model2, verbose=T, burnin=1e+5, interval=1e+5, control = control.gof.ergm(nsim = 200))
# If you run below and then wouldn't see the plot, try par(mar=c(2,2,2,2))
dev.off()
plot(gof2)
gof2
```

::: {.callout-note style="color: purple"}
Note: Your gof graph should have 5 subplots corresponding to the 5 parameters of your model. The dark black line represents the data for the observed network. The boxplots represent the distribution of corresponding degrees across the simulated networks, and the soft lines are the 95% confidence intervals. In general, for configurations in the model, the fit is considered good if │t│≤ 0.1. For configurations not included in the model, the fit is considered good if 0.1\<│t│≤ 1, and not extreme if 1\<│t│≤ 2. If │t│\> 2 the fit is bad.
:::

------------------------------------------------------------------------

Check your submission for grammar - points may be deducted for lack of clarity.

Click 'Render' button at the top of the screen, or press cmd + shift + k. Note. It might take some time for you computer to render this document as a PDF, since it will be running all code chunks.

Deliverables to submit on Canvas:

1.  Your report as a .pdf file
2.  Your code as a .qmd file
3.  Your data as a .RData file

```{r}
save.image(file = "lab3.RData")
```

Please upload each file separately -- do not upload as a zip file! *(Please)*

### Endogenous Effects (Effects of the ties being predicted on other predicted ties)

● ***edges***: number of edges in the network

● ***mutual*****:** number of reciprocal edges in the network

●  ***gwidegree**: Geometrically Weighted Indegree*. This term measures a tendency *against* indegree preferential attachment. (Negative coefficients show indegree preferential attachment -- Incoming ties are more likely to be directed towards nodes that already have other incoming ties.)

● ***gwodegree**: Directed Geometrically Weighted Outdegree.* This term measures a tendency *against* outdegree preferential attachment. (Negative coefficients show outdegree preferential attachment -- Outgoing ties are more likely to originate from nodes that already have other outgoing ties)

● ***dgwesp**, of type "OTP"*: *Directed Geometrically Weighted Edgewise Shared Partners* Number of edges that belong to certain types of triangles. "Edgewise" refers to the fact that we require a tie to exist between nodes i and j, and then measure the number of "shared partners" between them. Shared partners are nodes that have a certain relationship between i and j. In this case, we are looking at the Outgoing Two Path ("OTP") relationships. This is one way to operationalize transitivity. The "geometrically weighted" refers to the fact that we will use a weight parameter,, to add diminishing returns to the number of shared partners (i.e., the second shared partner between two nodes will have less effect on the likelihood of a network than the first shared partner, the third will have even less of an effect, and so on).

Yes, geometrically weighted terms (gwidegree, gwodegree, dgwesp) are very complicated. Essentially, the "geometric weighted" part is saying that effects on network probability have diminishing returns for nodes as degree or the number of shared partners gets higher and higher. This helps avoid model fits where all the ties are directed towards one node. For the purposes of this class, you can ignore the technical details and just focus on interpreting them in terms of "preferential attachment" or "transitivity" effects.

### **Exogenous Effects (Effects of node attributes or variables outside the predicted ties)**

● ***nodeicov***: covariance between in-degree of nodes and attributes of nodes

● ***nodeocov***: covariance between out-degree of nodes and attributes of nodes

● ***diff***: differences between nodes on some numeric attribute (ex. tenure, age). The way we have it specified in the code, diff scores are is calculated as the attribute value of the sending node (attb~i~) minus value of the receiving node (attb~j~). (Heterophily/ anti-homophily on continuous variables).

● ***nodematc**h*: tendency of nodes to form ties with those of matching values (Homophily on categorical variables)

● ***nodemix***: mixing matrix of all different combinations of node attributes (ex. A -\> A ties, A-\> B ties, B -\> A ties, B -\> B ties). To avoid model overspecification, we need to leave one of these cells out of the model. The weights (effect sizes) estimated for all of the terms we leave in the model then represent the effect of a combination relative to the effect that we left out.

● ***edgecov***: covariance between edges of two networks (the presence/strength of a tie in an outside network on whether a tie exists in our dependent variable network -- Advice)
